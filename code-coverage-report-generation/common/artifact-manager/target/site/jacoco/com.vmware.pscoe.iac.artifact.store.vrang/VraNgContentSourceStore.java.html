<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VraNgContentSourceStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">artifact-manager</a> &gt; <a href="index.source.html" class="el_package">com.vmware.pscoe.iac.artifact.store.vrang</a> &gt; <span class="el_source">VraNgContentSourceStore.java</span></div><h1>VraNgContentSourceStore.java</h1><pre class="source lang-java linenums">package com.vmware.pscoe.iac.artifact.store.vrang;

/*
 * #%L
 * artifact-manager
 * %%
 * Copyright (C) 2023 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 * 
 * This product is licensed to you under the BSD-2 license (the &quot;License&quot;). You may not use this product except in compliance with the BSD-2 License.  
 * 
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.stream.JsonReader;
import com.vmware.pscoe.iac.artifact.configuration.ConfigurationVraNg;
import com.vmware.pscoe.iac.artifact.model.Package;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgContentSource;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgContentSourceBase;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgContentSourceType;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgIntegration;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgPackageDescriptor;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgWorkflow;
import com.vmware.pscoe.iac.artifact.model.vrang.VraNgWorkflowContentSource;
import com.vmware.pscoe.iac.artifact.rest.RestClientVraNg;
import com.vmware.pscoe.iac.artifact.store.filters.CustomFolderFileFilter;
import com.vmware.pscoe.iac.artifact.utils.VraNgIntegrationUtils;
import org.apache.commons.lang3.StringUtils;

<span class="fc" id="L43">public class VraNgContentSourceStore extends AbstractVraNgStore {</span>
	private String projectId;
	private VrangContentSourceUtils utils;
	private VraNgIntegration configuredIntegration;
<span class="fc" id="L47">	private List&lt;VraNgContentSourceBase&gt; existingSources = null;</span>

	@Override
	public void init(RestClientVraNg restClient, Package vraNgPackage, ConfigurationVraNg config, VraNgPackageDescriptor vraNgPackageDescriptor) {
<span class="fc" id="L51">		super.init(restClient, vraNgPackage, config, vraNgPackageDescriptor);</span>
<span class="fc" id="L52">		this.utils					= new VrangContentSourceUtils(restClient, vraNgPackage);</span>
<span class="fc" id="L53">		this.projectId				= this.restClient.getProjectId();</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">		this.configuredIntegration	= !StringUtils.isEmpty(this.config.getVroIntegration())</span>
<span class="nc" id="L55">									? this.restClient.getVraWorkflowIntegration(this.config.getVroIntegration())</span>
<span class="fc" id="L56">									: new VraNgIntegration();</span>
<span class="fc" id="L57">	}</span>

	@Override
	public void importContent(File sourceDirectory) {
<span class="nc" id="L61">		logger.info(&quot;Importing files from the '{}' directory&quot;, VraNgDirs.DIR_CONTENT_SOURCES);</span>
<span class="nc" id="L62">		File contentSourceFolder = Paths.get(sourceDirectory.getPath(), VraNgDirs.DIR_CONTENT_SOURCES).toFile();</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">		if (!contentSourceFolder.exists()) {</span>
<span class="nc" id="L64">			logger.info(&quot;Content Source folder is missing '{}' &quot;, VraNgDirs.DIR_CONTENT_SOURCES);</span>
<span class="nc" id="L65">			return;</span>
		}
		// Check if there are any blueprints to import
<span class="nc" id="L68">		File[] localList = this.filterBasedOnConfiguration(contentSourceFolder, new CustomFolderFileFilter(this.getItemListFromDescriptor()));</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">		if (localList == null || localList.length == 0) {</span>
<span class="nc" id="L70">			logger.info(&quot;No Content Source available - skip import&quot;);</span>
<span class="nc" id="L71">			return;</span>
		}
<span class="nc bnc" id="L73" title="All 2 branches missed.">		for (File cs : localList) {</span>
<span class="nc" id="L74">			this.importFile(cs);</span>
		}
<span class="nc" id="L76">	}</span>

	/**
	 * Used to fetch the store's data from the package descriptor
	 *
	 * @return list of content sources
	 */
	@Override
	protected List&lt;String&gt; getItemListFromDescriptor() {
<span class="fc" id="L85">		return this.vraNgPackageDescriptor.getContentSource();</span>
	}

	/**
	 * Exports all content sources from service broker.
	 * Passing null to exportStoreContent and by extension to fetchAllContentSources will not apply a filter to the
	 * 	content sources.
	 */
	@Override
	protected void exportStoreContent() {
<span class="fc" id="L95">		this.exportStoreContent( null );</span>
<span class="fc" id="L96">	}</span>

	/**
	 * Exports filtered content sources from service broker
	 * If the content source is a VRO_WORKFLOW then it is checked if it has unique
	 * workflow names.sssss
	 *
	 * @param contentSourceNames list of names
	 */
	@Override
	protected void exportStoreContent(List&lt;String&gt; contentSourceNames) {
<span class="fc bfc" id="L107" title="All 2 branches covered.">		if (contentSourceNames != null) {</span>
<span class="fc" id="L108">			List&lt;VraNgContentSourceBase&gt; contentSources = this.validateNoDuplicateWf(</span>
<span class="fc" id="L109">					this.fetchAllContentSources(contentSourceNames));</span>
<span class="nc" id="L110">			contentSourceNames.forEach(contentSourceName -&gt; {</span>
<span class="fc" id="L111">				VraNgContentSourceBase contentSource = contentSources.stream()</span>
<span class="pc" id="L112">						.filter(cs -&gt; contentSourceName.equals(cs.getName()))</span>
<span class="fc" id="L113">						.findAny().orElse(null);</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">				if (contentSource == null) {</span>
<span class="fc" id="L115">					throw new IllegalStateException(</span>
<span class="fc" id="L116">							String.format(</span>
									&quot;Content Source [%s] not found on the server.&quot;,
									contentSourceName));
				}
<span class="nc" id="L120">				this.utils.storeContentSourceOnFilesystem(contentSource);</span>
<span class="nc" id="L121">			});</span>
		}
<span class="fc" id="L123">	}</span>

	/**
	 * Checks for duplicate workflows in the given content sources
	 *
	 * @param	contentSources - Content sources to check
	 */
	private List&lt;VraNgContentSourceBase&gt; validateNoDuplicateWf( List&lt;VraNgContentSourceBase&gt; contentSources ) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		for ( VraNgContentSourceBase contentSource: contentSources ) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">			if ( contentSource.getType() == VraNgContentSourceType.VRO_WORKFLOW ) {</span>
<span class="nc" id="L133">				ArrayList&lt;String&gt; duplicateWorkflows	= getDuplicateWorkflows( ( VraNgWorkflowContentSource ) contentSource );</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">				if ( duplicateWorkflows.size() &gt; 0 ) {</span>
<span class="nc" id="L136">					throw new RuntimeException(</span>
						&quot;Cannot have workflows with the same name in one content source. Problematic Workflows: &quot;
<span class="nc" id="L138">							+ String.join( &quot;, &quot;, duplicateWorkflows )</span>
					);
				}
			}
<span class="nc" id="L142">		}</span>

<span class="fc" id="L144">		return contentSources;</span>
	}

	void importFile(File contentSourceFile) {
<span class="nc" id="L148">		try (JsonReader reader = new JsonReader(new FileReader(contentSourceFile.getPath()))) {</span>
<span class="nc" id="L149">			JsonObject jsonObj = JsonParser.parseReader(reader).getAsJsonObject();</span>
<span class="nc" id="L150">			VraNgContentSourceType type = VraNgContentSourceType.fromString(jsonObj.get(&quot;typeId&quot;).getAsString());</span>
<span class="nc" id="L151">			VraNgContentSourceBase contentSource = new Gson().fromJson(jsonObj, type.getTypeClass());</span>
<span class="nc bnc" id="L152" title="All 3 branches missed.">			switch (type) {</span>
				case VRO_WORKFLOW:
<span class="nc" id="L154">					this.prepareWorkflowContentSource((VraNgWorkflowContentSource) contentSource);</span>
<span class="nc" id="L155">					break;</span>
				case BLUEPRINT:
				case CODE_STREAM:
				case ABX_ACTIONS:
<span class="nc" id="L159">					this.prepareProjectContentSource((VraNgContentSource) contentSource);</span>
<span class="nc" id="L160">					break;</span>
				default:
<span class="nc" id="L162">					logger.info(&quot;Skipping import of content source {}. Type {} is not handled!&quot;, contentSource.getName(), contentSource.getType());</span>
<span class="nc" id="L163">					return;</span>
			}
<span class="nc" id="L165">			this.utils.syncContentSource(contentSource, this.config.getImportTimeout());</span>

<span class="nc" id="L167">		} catch (IOException e) {</span>
<span class="nc" id="L168">			throw new RuntimeException(e);</span>
<span class="nc" id="L169">		}</span>
<span class="nc" id="L170">	}</span>

	public void prepareWorkflowContentSource(VraNgWorkflowContentSource contentSource) {
<span class="nc" id="L173">		VraNgIntegration defaultIntegration = VraNgIntegrationUtils.getInstance()</span>
<span class="nc" id="L174">			.getDefaultVraIntegration(this.restClient);</span>

<span class="nc" id="L176">		ArrayList&lt;String&gt; duplicateWorkflows	= getDuplicateWorkflows( contentSource );</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">		if ( duplicateWorkflows.size() &gt; 0 ) {</span>
<span class="nc" id="L179">			throw new RuntimeException(</span>
				&quot;Cannot have workflows with the same name in one content source. Problematic Workflows: &quot;
<span class="nc" id="L181">					+ String.join( &quot;, &quot;, duplicateWorkflows )</span>
			);
		}

<span class="nc" id="L185">		List&lt;String&gt; wfIds = getWfIds(contentSource);</span>
		// Find same content source by comparing id or name or workflows ids in order list
<span class="nc" id="L187">		String newId = this.getExistingSourcesFilteredByType(contentSource.getType(), VraNgWorkflowContentSource.class)</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			.filter(existingCS -&gt; existingCS.getName().equals(contentSource.getName())</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">				|| existingCS.getId().equals(contentSource.getId())</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">				|| getWfIds(existingCS).equals(wfIds))</span>
<span class="nc" id="L191">			.map(existingCS -&gt; existingCS.getId())</span>
<span class="nc" id="L192">			.findFirst()</span>
<span class="nc" id="L193">			.orElse(&quot;&quot;);</span>
<span class="nc" id="L194">		contentSource.setId(newId);</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">		for (VraNgWorkflow workflow : contentSource.getConfig().getWorkflows()) {</span>
<span class="nc bnc" id="L197" title="All 4 branches missed.">			if (workflow == null || workflow.getIntegration() == null) {</span>
<span class="nc" id="L198">				continue;</span>
			}
<span class="nc bnc" id="L200" title="All 2 branches missed.">			if (!StringUtils.isEmpty(configuredIntegration.getName())) {</span>
<span class="nc" id="L201">				setIntegration(workflow, configuredIntegration);</span>
<span class="nc" id="L202">				continue;</span>
			}
<span class="nc" id="L204">			VraNgIntegration workflowIntegration = this.restClient.getVraWorkflowIntegration(workflow.getIntegration().getName());</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">			if (!StringUtils.isEmpty(workflowIntegration.getName())) {</span>
<span class="nc" id="L206">				setIntegration(workflow, workflowIntegration);</span>
<span class="nc" id="L207">				continue;</span>
			}
<span class="nc bnc" id="L209" title="All 2 branches missed.">			if (!StringUtils.isEmpty(defaultIntegration.getName())) {</span>
<span class="nc" id="L210">				logger.warn(&quot;Unable to find integration '{}' on host '{}' setting default integration to '{}'&quot;,</span>
<span class="nc" id="L211">					workflow.getIntegration().getName(), this.config.getHost(), defaultIntegration.getName());</span>
<span class="nc" id="L212">				setIntegration(workflow, defaultIntegration);</span>
<span class="nc" id="L213">				continue;</span>
			}

<span class="nc" id="L216">			logger.warn(</span>
				&quot;Unable to find all of the following integrations on host '{}' configured : '{}' , resource: '{}' , default : '{}' &quot;,
<span class="nc" id="L218">				this.config.getHost(), this.config.getVroIntegration(), workflow.getIntegration().getName(),</span>
				VraNgIntegrationUtils.DEFAULT_INTEGRATION_NAME);
<span class="nc" id="L220">		}</span>

<span class="nc" id="L222">		this.deleteBeforeCreation(contentSource.getId());</span>
<span class="nc" id="L223">	}</span>

	private void setIntegration(VraNgWorkflow workflow, VraNgIntegration targetIntegration) {
<span class="nc" id="L226">		workflow.getIntegration().setEndpointConfigurationLink(targetIntegration.getEndpointConfigurationLink());</span>
<span class="nc" id="L227">		workflow.getIntegration().setEndpointUri(targetIntegration.getEndpointUri());</span>
<span class="nc" id="L228">		workflow.getIntegration().setName(targetIntegration.getName());</span>
<span class="nc" id="L229">	}</span>

	private List&lt;String&gt; getWfIds(VraNgWorkflowContentSource contentSource) {
<span class="nc" id="L232">		return contentSource</span>
<span class="nc" id="L233">			.getConfig()</span>
<span class="nc" id="L234">			.getWorkflows()</span>
<span class="nc" id="L235">			.stream()</span>
<span class="nc" id="L236">			.map(integration -&gt; integration.getId())</span>
<span class="nc" id="L237">			.sorted()</span>
<span class="nc" id="L238">			.collect(Collectors.toList());</span>
	}

	/**
	 * Checks if there are any duplicate named workflows.
	 * A set will return false when doing Set.add if the item already exists
	 *
	 * https://docs.oracle.com/javase/8/docs/api/java/util/Set.html#add-E-
	 *
	 * @return	ArrayList&lt;String&gt;
	 */
	private ArrayList&lt;String&gt; getDuplicateWorkflows(VraNgWorkflowContentSource contentSource) {
<span class="nc" id="L250">		ArrayList&lt;String&gt; duplicates	= new ArrayList&lt;&gt;();</span>
<span class="nc" id="L251">		Set&lt;String&gt; items				= new HashSet&lt;&gt;();</span>
<span class="nc" id="L252">		List&lt;VraNgWorkflow&gt; workflows	= contentSource.getConfig().getWorkflows();</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">		for ( VraNgWorkflow workflow: workflows ) {</span>
<span class="nc" id="L255">			String workflowName	= workflow.getName();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if ( ! items.add( workflowName ) ) {</span>
<span class="nc" id="L257">				duplicates.add( workflowName );</span>
			}
<span class="nc" id="L259">		}</span>

<span class="nc" id="L261">		return duplicates;</span>
	}

	public void prepareProjectContentSource(VraNgContentSource contentSource) {
<span class="nc" id="L265">		Map&lt;String, String&gt; config = new HashMap&lt;&gt;();</span>
<span class="nc" id="L266">		config.put(&quot;sourceProjectId&quot;, this.projectId);</span>
<span class="nc" id="L267">		contentSource.setConfig(config);</span>
<span class="nc" id="L268">		contentSource.setProjectId(this.projectId);</span>
<span class="nc" id="L269">		String newId = this.fetchAllContentSources( null )</span>
<span class="nc" id="L270">			.stream()</span>
<span class="nc" id="L271">			.filter(existingCS -&gt; existingCS.getType().equals(contentSource.getType()))</span>
<span class="nc" id="L272">			.map(existingCS -&gt; existingCS.getId())</span>
<span class="nc" id="L273">			.findFirst()</span>
<span class="nc" id="L274">			.orElse(&quot;&quot;);</span>
<span class="nc" id="L275">		contentSource.setId(newId);</span>
<span class="nc" id="L276">	}</span>

	protected void deleteBeforeCreation(String contentSourceId) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">		if (contentSourceId != null) {</span>
			// VRA version 8.0 complains with message 'content source already exists' if try to update it
			// that's why delete content source prior updating it if VRA is 8.0
			// VRA version 8.1 and newer does update the content source without complaining
<span class="nc bnc" id="L283" title="All 2 branches missed.">			if (!this.restClient.isVraAbove81()) {</span>
<span class="nc" id="L284">				this.restClient.deleteContentSource(contentSourceId);</span>
			}
		}
<span class="nc" id="L287">	}</span>

	private &lt;T&gt; Stream&lt;T&gt; getExistingSourcesFilteredByType(VraNgContentSourceType type, Class&lt;T&gt; clazz) {
<span class="nc" id="L290">		return this.fetchAllContentSources( null ).stream().filter(src -&gt; src.getType().equals(type)).map(clazz::cast);</span>
	}

	/**
	 * Gets all the content sources on the server.
	 * This will filter content sources that are not of the configured project id.
	 * If the content source is not associated with a project, it will be fetched as well.
	 * Passing contentSourceNames will mean that only they will be fetched. Passing null means all are accepted.
	 * The reason why we need 2 streams and 2 filters is since we want to cache ALL existing sources but we want the filter to be
	 * 	dynamic.
	 *
	 * @param	contentSourceNames - names to filter for or null for accept all
	 *
	 * @return	List&lt;VraNgContentSourceBase&gt;
	 */
	private List&lt;VraNgContentSourceBase&gt; fetchAllContentSources( List&lt;String&gt; contentSourceNames ) {
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">		if ( this.existingSources == null ) {</span>
<span class="fc" id="L307">			this.existingSources	= this.restClient</span>
<span class="fc" id="L308">				.getContentSourcesForProject( this.projectId )</span>
<span class="fc" id="L309">				.stream()</span>
<span class="pc" id="L310">				.filter( src -&gt; this.utils.isForSameOrNoneProject( src, this.projectId ) )</span>
<span class="fc" id="L311">				.collect( Collectors.toList() );</span>
		}

<span class="fc" id="L314">		return this.existingSources</span>
<span class="fc" id="L315">			.stream()</span>
<span class="pc bnc" id="L316" title="All 4 branches missed.">			.filter( src -&gt; contentSourceNames == null || contentSourceNames.contains( src.getName() ) )</span>
<span class="fc" id="L317">			.collect( Collectors.toList() );</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>