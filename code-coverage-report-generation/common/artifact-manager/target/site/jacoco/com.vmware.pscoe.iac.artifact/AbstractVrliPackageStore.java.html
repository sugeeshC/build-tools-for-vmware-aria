<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractVrliPackageStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">artifact-manager</a> &gt; <a href="index.source.html" class="el_package">com.vmware.pscoe.iac.artifact</a> &gt; <span class="el_source">AbstractVrliPackageStore.java</span></div><h1>AbstractVrliPackageStore.java</h1><pre class="source lang-java linenums">package com.vmware.pscoe.iac.artifact;

/*-
 * #%L
 * artifact-manager
 * %%
 * Copyright (C) 2023 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 * 
 * This product is licensed to you under the BSD-2 license (the &quot;License&quot;). You may not use this product except in compliance with the BSD-2 License.  
 * 
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */

import com.vmware.pscoe.iac.artifact.model.Package;
import com.vmware.pscoe.iac.artifact.model.PackageContent;
import com.vmware.pscoe.iac.artifact.model.vrli.VrliPackageDescriptor;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;

<span class="nc" id="L32">public abstract class AbstractVrliPackageStore extends GenericPackageStore&lt;VrliPackageDescriptor&gt; {</span>
	/**
	 * Constant for the alerts directory.
	 */
	protected static final String DIR_ALERTS = &quot;alerts&quot;;

	/**
	 * Constant for the content packs directory.
	 */
<span class="nc" id="L41">	private final String dirContentPacks = &quot;content_packs&quot;;</span>

	/**
	 * Variable for logging.
	 */
	protected Logger logger;

	/**
	 *
	 * @param pkg package to export
	 * @param vrliPackageDescriptor descriptor of the package
	 * @param dryrun whether it should be a dry run
	 * @return exported package
	 */
	@Override
	public final Package exportPackage(final Package pkg, final VrliPackageDescriptor vrliPackageDescriptor, final boolean dryrun) {
<span class="nc" id="L57">		logger.info(String.format(PackageStore.PACKAGE_EXPORT, pkg));</span>
<span class="nc" id="L58">		List&lt;String&gt; alertNames = vrliPackageDescriptor.getAlerts();</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">		if (alertNames != null) {</span>
<span class="nc" id="L60">			this.exportAlerts(pkg, alertNames);</span>
		} else {
<span class="nc" id="L62">			logger.info(&quot;No alerts found in content.yaml&quot;);</span>
		}
<span class="nc" id="L64">		List&lt;String&gt; contentPackNames = vrliPackageDescriptor.getContentPacks();</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">		if (contentPackNames != null) {</span>
<span class="nc" id="L66">			this.exportContentPacks(pkg, contentPackNames);</span>
		} else {
<span class="nc" id="L68">			logger.info(&quot;No content packs found in content.yaml&quot;);</span>
		}

<span class="nc" id="L71">		return pkg;</span>
	}


	/**
	 * @param pkgs packages to export
	 * @param dryrun whether it should be a dry run
	 * @return exported packages
	 */
	@Override
	public final List&lt;Package&gt; exportAllPackages(final List&lt;Package&gt; pkgs, final boolean dryrun) {
<span class="nc" id="L82">		this.vlidateServer(pkgs);</span>

<span class="nc" id="L84">		List&lt;Package&gt; sourceEndpointPackages = pkgs;</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">		if (sourceEndpointPackages.isEmpty()) {</span>
<span class="nc" id="L86">			return new ArrayList&lt;&gt;();</span>
		}
<span class="nc" id="L88">		List&lt;Package&gt; exportedPackages = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		for (Package pkg : pkgs) {</span>
<span class="nc" id="L90">			VrliPackageDescriptor descriptor = VrliPackageDescriptor.getInstance(new File(pkg.getFilesystemPath()));</span>
<span class="nc" id="L91">			exportedPackages.add(this.exportPackage(pkg, descriptor, dryrun));</span>
<span class="nc" id="L92">		}</span>

<span class="nc" id="L94">		return exportedPackages;</span>
	}


	/**
	 *
	 * @param pkgs packages to import
	 * @param dryrun whether it should be a dry run
	 * @param mergePackages whether to merge packages
	 * @param enableBackup whether to enable package backup
	 * @return imported packages
	 */
	@Override
	public final List&lt;Package&gt; importAllPackages(final List&lt;Package&gt; pkgs, final boolean dryrun, final boolean mergePackages, final boolean enableBackup) {
<span class="nc" id="L108">		this.validateFilesystem(pkgs);</span>

<span class="nc" id="L110">		List&lt;Package&gt; sourceEndpointPackages = pkgs;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (sourceEndpointPackages.isEmpty()) {</span>
<span class="nc" id="L112">			return new ArrayList&lt;&gt;();</span>
		}
<span class="nc" id="L114">		List&lt;Package&gt; importedPackages = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">		for (Package pkg : sourceEndpointPackages) {</span>
<span class="nc" id="L116">			importedPackages.add(this.importPackage(pkg, dryrun, mergePackages));</span>
<span class="nc" id="L117">		}</span>

<span class="nc" id="L119">		return importedPackages;</span>
	}


	/**
	 *
	 * @param pkg packages to import
	 * @param dryrun whether it should be a dry run
	 * @param enableBackup whether to enable package backup
	 * @return imported packages
	 */
	@Override
	public final List&lt;Package&gt; importAllPackages(final List&lt;Package&gt; pkg, final boolean dryrun, final boolean enableBackup) {
<span class="nc" id="L132">		return this.importAllPackages(pkg, dryrun, false, enableBackup);</span>
	}


	/** 
	* @param pkg package to export
	* @param dryrun whether it should be a dry run
	* @return exported package
	*/
	@Override
	public final Package exportPackage(final Package pkg, final boolean dryrun) {
<span class="nc" id="L143">		VrliPackageDescriptor descriptor = VrliPackageDescriptor.getInstance(new File(pkg.getFilesystemPath()));</span>

<span class="nc" id="L145">		return this.exportPackage(pkg, descriptor, dryrun);</span>
	}

	/**
	 * @param pkg package to export
	 * @param exportDescriptor description of the exported package
	 * @param dryrun whether it should be a dry run
	 * @return exported package
	 */
	@Override
	public final Package exportPackage(final Package pkg, final File exportDescriptor, final boolean dryrun) {
<span class="nc" id="L156">		VrliPackageDescriptor descriptor = VrliPackageDescriptor.getInstance(exportDescriptor);</span>

<span class="nc" id="L158">		return this.exportPackage(pkg, descriptor, dryrun);</span>
	}

	/**
	 * @param pkg package to import
	 * @param dryrun whether it should be a dry run
	 * @param mergePackages whether to merge the packages
	 * @return imported package
	 */
	@Override
	public final Package importPackage(final Package pkg, final boolean dryrun, final boolean mergePackages) {
<span class="nc" id="L169">		logger.info(String.format(PackageStore.PACKAGE_IMPORT, pkg));</span>

		File tmp;
		try {
<span class="nc" id="L173">			tmp = Files.createTempDirectory(&quot;vrbt-temp-import-dir&quot;).toFile();</span>
<span class="nc" id="L174">			logger.info(&quot;Created temp dir {}&quot;, tmp.getAbsolutePath());</span>
<span class="nc" id="L175">			new PackageManager(pkg).unpack(tmp);</span>
<span class="nc" id="L176">		} catch (IOException e) {</span>
<span class="nc" id="L177">			logger.error(&quot;Unable to extract package '{}' in temporary directory.&quot;, pkg.getFQName());</span>
<span class="nc" id="L178">			throw new RuntimeException(&quot;Unable to extract pacakge.&quot;, e);</span>
<span class="nc" id="L179">		}</span>
<span class="nc" id="L180">		importAlerts(tmp);</span>
<span class="nc" id="L181">		importContentPacks(tmp);</span>

<span class="nc" id="L183">		return pkg;</span>
	}

	/**
	 * @param tmp the temp file to import alerts from
	 */
	protected final void importAlerts(final File tmp) {
<span class="nc" id="L190">		File alertsDirectory = Paths.get(tmp.getPath(), DIR_ALERTS).toFile();</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">		if (alertsDirectory.exists()) {</span>
<span class="nc" id="L193">			FileUtils.listFiles(alertsDirectory, new String[] {&quot;json&quot;}, false).stream().forEach(this::importAlert);</span>
		}
<span class="nc" id="L195">	}</span>

	/**
	 * @param tmp the temp file to import content packs from
	 */
	protected final void importContentPacks(final File tmp) {
<span class="nc" id="L201">		File contentPacksDirectory = Paths.get(tmp.getPath(), dirContentPacks).toFile();</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">		if (contentPacksDirectory.exists()) {</span>
<span class="nc" id="L204">			FileUtils.listFiles(contentPacksDirectory, new String[] {&quot;json&quot;}, false).stream().forEach(this::importContentPack);</span>
		}
<span class="nc" id="L206">	}</span>

	/**
	 *
	 * @return the packages that are received
	 */
	@Override
	public final List&lt;Package&gt; getPackages() {
<span class="nc" id="L214">		throw new UnsupportedOperationException(&quot;getPackages: vRLI does not provide native package support.&quot;);</span>
	}

	/**
	 * @param pkg packages to delete
	 * @param withContent whather to delete the package with content
	 * @param dryrun whether it should be a dry run
	 * @return the deleted package
	 */
	@Override
	protected final Package deletePackage(final Package pkg, final boolean withContent, final boolean dryrun) {
<span class="nc" id="L225">		throw new UnsupportedOperationException(&quot;deletePackage: vRLI does not provide native package support.&quot;);</span>
	}

	/**
	 * @param pkg package to get
	 * @return the package content
	 */
	@Override
	protected final PackageContent getPackageContent(final Package pkg) {
<span class="nc" id="L234">		throw new UnsupportedOperationException(&quot;getPackageContent: vRLI does not provide native package support.&quot;);</span>
	}

	/**
	 * @param content content to be deleted
	 * @param dryrun whether it should be a dry run
	 */
	@Override
	protected final void deleteContent(final PackageContent.Content content, final boolean dryrun) {
<span class="nc" id="L243">		throw new UnsupportedOperationException(&quot;deleteContent: vRLI does not provide native package support.&quot;);</span>
	}

	/**
	 * @param vrliPakage package to export content from
	 * @param contentPackName the name of the package
	 * @param contentPackData the content of the package
	 * @return the file with the exports
	 */
	protected final File exportContentPack(final Package vrliPakage, final String contentPackName, final String contentPackData) {
<span class="nc" id="L253">		File store = new File(vrliPakage.getFilesystemPath());</span>
<span class="nc" id="L254">		File contentPacksFile = Paths.get(store.getPath(), dirContentPacks, contentPackName + &quot;.json&quot;).toFile();</span>
<span class="nc" id="L255">		contentPacksFile.getParentFile().mkdirs();</span>

		try {
<span class="nc" id="L258">			logger.info(&quot;Exporting content pack '{}'&quot;, contentPackName);</span>
<span class="nc" id="L259">			Files.write(Paths.get(contentPacksFile.getPath()), contentPackData.getBytes(), StandardOpenOption.CREATE);</span>
<span class="nc" id="L260">		} catch (IOException e) {</span>
<span class="nc" id="L261">			logger.error(&quot;Unable to store content pack {} {}&quot;, contentPackName, contentPacksFile.getPath());</span>
<span class="nc" id="L262">			throw new RuntimeException(String.format(&quot;Unable to store content pack '%s' : %s.&quot;, contentPackName, e.getMessage()));</span>
<span class="nc" id="L263">		}</span>

<span class="nc" id="L265">		return contentPacksFile;</span>
	}

	/**
	 * @param alertFile the file with the alert to import
	 */
	protected abstract void importAlert(File alertFile);

	/**
	 * @param contentPackFile the file with the content pack to import
	 */
	protected abstract void importContentPack(File contentPackFile);

	/**
	 * @param vrliPakage the vrli package to export alerts from
	 * @param alertNames the alert names to export
	 */
	protected abstract void exportAlerts(Package vrliPakage, List&lt;String&gt; alertNames);

	/**
	 * @param vrliPakage the vrli package to export content pack from
	 * @param contentPackNames the content pack names to export
	 */
	protected abstract void exportContentPacks(Package vrliPakage, List&lt;String&gt; contentPackNames);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>