<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CsPackageStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">artifact-manager</a> &gt; <a href="index.source.html" class="el_package">com.vmware.pscoe.iac.artifact</a> &gt; <span class="el_source">CsPackageStore.java</span></div><h1>CsPackageStore.java</h1><pre class="source lang-java linenums">package com.vmware.pscoe.iac.artifact;

/*
 * #%L
 * artifact-manager
 * %%
 * Copyright (C) 2023 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 * 
 * This product is licensed to you under the BSD-2 license (the &quot;License&quot;). You may not use this product except in compliance with the BSD-2 License.  
 * 
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import com.vmware.pscoe.iac.artifact.configuration.ConfigurationCs;
import com.vmware.pscoe.iac.artifact.model.Package;
import com.vmware.pscoe.iac.artifact.model.PackageContent.Content;
import com.vmware.pscoe.iac.artifact.model.cs.CsPackageContent;
import com.vmware.pscoe.iac.artifact.model.cs.CsPackageDescriptor;
import com.vmware.pscoe.iac.artifact.rest.RestClientCs;
import com.vmware.pscoe.iac.artifact.store.cs.CsTypeStoreFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CsPackageStore extends GenericPackageStore&lt;CsPackageDescriptor&gt; {
	/**
	 * Variable for logging.
	 */
<span class="nc" id="L37">	private final Logger logger = LoggerFactory.getLogger(CsPackageStore.class);</span>

	/**
	 * The CSA rest client.
	 */
	private final RestClientCs restClient;

	/**
	 * The CS configuration.
	 */
	private final ConfigurationCs config;

	/**
	 *
	 * @param csRestClient the cs rest client
	 * @param csConfig the cs config details
	 */
<span class="nc" id="L54">	protected CsPackageStore(final RestClientCs csRestClient, final ConfigurationCs csConfig) {</span>
<span class="nc" id="L55">		this.restClient = csRestClient;</span>
<span class="nc" id="L56">		this.config = csConfig;</span>
<span class="nc" id="L57">	}</span>

	/**
	 * Returns the packages.
	 * @return the list of packages to return
	 */
	@Override
	public final List&lt;Package&gt; getPackages() {
<span class="nc" id="L65">		throw new UnsupportedOperationException(&quot;getPackages: Code Stream Services does not provide native support for packages.&quot;);</span>
	}

	/**
	 * Exports all the packages.
	 * @param csPackages the cs packages to export
	 * @param dryrun whether it should be dry run
	 * @return the exported packages
	 */
	@Override
	public final List&lt;Package&gt; exportAllPackages(final List&lt;Package&gt; csPackages, final boolean dryrun) {
<span class="nc" id="L76">		this.vlidateServer(csPackages);</span>

<span class="nc" id="L78">		List&lt;Package&gt; sourceEndpointPackages = csPackages;</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">		if (sourceEndpointPackages.isEmpty()) {</span>
<span class="nc" id="L81">			return new ArrayList&lt;&gt;();</span>
		}

<span class="nc" id="L84">		List&lt;Package&gt; exportedPackages = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">		for (Package pkg : csPackages) {</span>
<span class="nc" id="L86">			CsPackageDescriptor csPackageDescriptor = CsPackageDescriptor</span>
<span class="nc" id="L87">					.getInstance(new File(pkg.getFilesystemPath()));</span>
<span class="nc" id="L88">			exportedPackages.add(this.exportPackage(pkg, csPackageDescriptor, dryrun));</span>
<span class="nc" id="L89">		}</span>

<span class="nc" id="L91">		return exportedPackages;</span>
	}

	/**
	 * Imports all packages.
	 * @param pkg the packages to import
	 * @param dryrun whether it should be dry run
	 * @param enableBackup whether it should back up the packages on import
	 * @return the imported packages
	 */
	@Override
	public final List&lt;Package&gt; importAllPackages(final List&lt;Package&gt; pkg, final boolean dryrun, final boolean enableBackup) {
<span class="nc" id="L103">		return this.importAllPackages(pkg, dryrun, false, enableBackup);</span>
	}

	/**
	 * Imports all packages.
	 * @param csPackages the packages to import
	 * @param dryrun whether it should be a dry dun
	 * @param mergePackages whether the packages should be merged
	 * @param enableBackup whether it should back up the packages on import
	 * @return the imported packages
	 */
	@Override
	public final List&lt;Package&gt; importAllPackages(final List&lt;Package&gt; csPackages, final boolean dryrun, final boolean mergePackages, final boolean enableBackup) {
<span class="nc" id="L116">		this.validateFilesystem(csPackages);</span>

<span class="nc" id="L118">		List&lt;Package&gt; sourceEndpointPackages = csPackages;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">		if (sourceEndpointPackages.isEmpty()) {</span>
<span class="nc" id="L120">			return new ArrayList&lt;&gt;();</span>
		}

<span class="nc" id="L123">		List&lt;Package&gt; importedPackages = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">		for (Package pkg : sourceEndpointPackages) {</span>
<span class="nc" id="L125">			importedPackages.add(this.importPackage(pkg, dryrun, mergePackages));</span>
<span class="nc" id="L126">		}</span>

<span class="nc" id="L128">		return importedPackages;</span>
	}

	/**
	 * Export a cs package.
	 * @param csPackage the package to export
	 * @param dryrun whether it should be a dry run
	 * @return the exported package
	 */
	@Override
	public final Package exportPackage(final Package csPackage, final boolean dryrun) {
<span class="nc" id="L139">		CsPackageDescriptor csPackageDescriptor = CsPackageDescriptor</span>
<span class="nc" id="L140">				.getInstance(new File(csPackage.getFilesystemPath()));</span>
<span class="nc" id="L141">		return this.exportPackage(csPackage, csPackageDescriptor, dryrun);</span>
	}

	/**
	 * Exports a cs package.
	 * @param csPackage the package to export
	 * @param csPackageDescriptor the package descriptor of the package to be exported
	 * @param dryrun whether it should be dry run
	 * @return the exported package
	 */
	@Override
	public final Package exportPackage(final Package csPackage, final CsPackageDescriptor csPackageDescriptor, final boolean dryrun) {
<span class="nc" id="L153">		logger.info(String.format(PackageStore.PACKAGE_EXPORT, csPackage));</span>
<span class="nc" id="L154">		CsTypeStoreFactory storeFactory = CsTypeStoreFactory.withConfig(restClient, csPackage, config, csPackageDescriptor);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">		for (CsPackageContent.ContentType type : CsTypeStoreFactory.EXPORT_ORDER) {</span>
<span class="nc" id="L156">			logger.info(&quot;EXPORTING: {}&quot;, type.getTypeValue());</span>
<span class="nc" id="L157">			storeFactory.getStoreForType(type).exportContent();</span>
		}

<span class="nc" id="L160">		return csPackage;</span>
	}

	/**
	 * Imports a cs package.
	 * @param csPackage the cs package to import
	 * @param dryrun whether it should be dry run
	 * @param mergePackages whether it should merge the packages
	 * @return the package to be imported
	 */
	@Override
	public final Package importPackage(final Package csPackage, final boolean dryrun, final boolean mergePackages) {
<span class="nc" id="L172">		logger.info(String.format(PackageStore.PACKAGE_IMPORT, csPackage));</span>

		File tmp;
		try {
<span class="nc" id="L176">			tmp = Files.createTempDirectory(&quot;iac-package-import&quot;).toFile();</span>
<span class="nc" id="L177">			logger.info(&quot;Created temp dir {}&quot;, tmp.getAbsolutePath());</span>
<span class="nc" id="L178">			new PackageManager(csPackage).unpack(tmp);</span>
<span class="nc" id="L179">		} catch (IOException e) {</span>
<span class="nc" id="L180">			logger.error(&quot;Unable to extract package '{}' in temporary directory.&quot;, csPackage.getFQName());</span>
<span class="nc" id="L181">			throw new RuntimeException(&quot;Unable to extract pacakge.&quot;, e);</span>
<span class="nc" id="L182">		}</span>

<span class="nc" id="L184">		CsTypeStoreFactory storeFactory = CsTypeStoreFactory.withConfig(restClient, csPackage, config, null);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">		for (CsPackageContent.ContentType type : CsTypeStoreFactory.IMPORT_ORDER) {</span>
<span class="nc" id="L186">			logger.info(&quot;IMPORTING : {}&quot;, type.getTypeValue());</span>
<span class="nc" id="L187">			storeFactory.getStoreForType(type).importContent(tmp);</span>
		}

<span class="nc" id="L190">		return csPackage;</span>
	}

	/**
	 * Exports a package.
	 * @param csPackage the cs package to import
	 * @param csPackageDescriptorFile the descriptor file of the package to be exported
	 * @param dryrun whether it should be dry run
	 * @return the package to be exported
	 */
	@Override
	public final Package exportPackage(final Package csPackage, final File csPackageDescriptorFile, final boolean dryrun) {
<span class="nc" id="L202">		CsPackageDescriptor csPackageDescriptor = CsPackageDescriptor.getInstance(csPackageDescriptorFile);</span>

<span class="nc" id="L204">		return this.exportPackage(csPackage, csPackageDescriptor, dryrun);</span>
	}

	/**
	 * Deletes a package.
	 * @param pkg the package to be deleted
	 * @param withContent whether it should delete the packate without the content
	 * @param dryrun whether it should be dry run
	 * @return the package to be deleted
	 */
	@Override
	protected final Package deletePackage(final Package pkg, final boolean withContent, final boolean dryrun) {
<span class="nc" id="L216">		throw new UnsupportedOperationException(&quot;deletePackage: Code Stream Services does not provide native support for packages.&quot;);</span>
	}

	/**
	 * Gets package content.
	 * @param pkg the package to get the content from
	 * @return the cs package content
	 */
	@Override
	protected final CsPackageContent getPackageContent(final Package pkg) {
<span class="nc" id="L226">		throw new UnsupportedOperationException(&quot;getPackageContent: Code Stream Services does not provide native support for packages.&quot;);</span>
	}

	/**
	 * Deleted content.
	 * @param content the content to be deleted
	 * @param dryrun whether it should be dry run
	 */
	@Override
	protected final void deleteContent(final Content content, final boolean dryrun) {
<span class="nc" id="L236">		throw new UnsupportedOperationException(&quot;deleteContent: Code Stream Services does not provide native support for packages.&quot;);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>