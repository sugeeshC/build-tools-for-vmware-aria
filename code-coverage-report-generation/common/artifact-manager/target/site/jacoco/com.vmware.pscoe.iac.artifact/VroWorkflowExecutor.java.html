<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VroWorkflowExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">artifact-manager</a> &gt; <a href="index.source.html" class="el_package">com.vmware.pscoe.iac.artifact</a> &gt; <span class="el_source">VroWorkflowExecutor.java</span></div><h1>VroWorkflowExecutor.java</h1><pre class="source lang-java linenums">package com.vmware.pscoe.iac.artifact;

/*
 * #%L
 * artifact-manager
 * %%
 * Copyright (C) 2023 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 * 
 * This product is licensed to you under the BSD-2 license (the &quot;License&quot;). You may not use this product except in compliance with the BSD-2 License.  
 * 
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */


import java.time.Duration;
import java.time.Instant;
import java.util.*;

import com.vmware.pscoe.iac.artifact.model.vro.WorkflowExecution;
import com.vmware.pscoe.iac.artifact.rest.RestClientVro;

public class VroWorkflowExecutor {

    // ANSI Console Color Text Escape Sequences.
    private static final String BRIGHT_FOREGROUND = &quot;\u001B[90m&quot;;
    private static final String NORMAL_FOREGROUND = &quot;\u001B[39m&quot;;
    private static final String NORMAL            = &quot;\u001B[0m&quot;;
    private static final String BRIGHT_RED        = &quot;\u001B[1;31m&quot;;
    private static final String RED               = &quot;\u001B[0;31m&quot;;
    private static final String BRIGHT_YELLOW     = &quot;\u001B[1;33m&quot;;
    private static final String YELLOW            = &quot;\u001B[0;33m&quot;;
    private static final String GREEN             = &quot;\u001B[0;32m&quot;;
<span class="nc" id="L37">    private static final Integer WORKFLOW_FINISH_POLL_INTERVAL = 250;</span>
<span class="nc" id="L38">    private static final Integer WORKFLOW_EXEC_POLL_INTERVAL = 1000;</span>

    private static final long SERVICE_UNAVAILABLE_SLEEP_MILLIS = 60000; // How long to sleep before retrying in case the service is not available.

    private RestClientVro restClient;

<span class="nc" id="L44">    public VroWorkflowExecutor(RestClientVro restClient) {</span>
<span class="nc" id="L45">        this.restClient = restClient;</span>
<span class="nc" id="L46">    }</span>

<span class="nc" id="L48">    HashSet&lt;String&gt; terminalStates = new HashSet&lt;&gt;(Arrays.asList(&quot;completed&quot;, &quot;failed&quot;, &quot;canceled&quot;));</span>

    /**
     * Executes a workflow synchronously and waits for it to finish/fail
     *
     * @param workflowId - The ID of the workflow
     * @param params     - Properties containing the input parameters of the workflow
     * @param timeout    - Timeout (in seconds) to wait for the workflow to finish
     * @return Properties containing all string output parameters of the workflow
     * @throws WorkflowExecutionException exception
     */
    public WorkflowExecution executeWorkflow(String workflowId, Properties params, int timeout) throws WorkflowExecutionException {
        // check whether workflow exists prior execution
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (!restClient.isWorkflowExisting(workflowId)) {</span>
<span class="nc" id="L62">            throw new WorkflowExecutionException(String.format(&quot;The workflow '%s' cannot be found on the target VRO '%s'&quot;, workflowId, restClient.getHost()));</span>
        }
<span class="nc" id="L64">        Properties inputParametersTypes = restClient.getInputParametersTypes(workflowId);</span>

<span class="nc" id="L66">        Set&lt;String&gt; printedMessages = new HashSet&lt;&gt;();</span>
<span class="nc" id="L67">        String executionId = restClient.startWorkflow(workflowId, params, inputParametersTypes);</span>
<span class="nc" id="L68">        Calendar timeoutAt = Calendar.getInstance();</span>
<span class="nc" id="L69">        timeoutAt.add(Calendar.SECOND, timeout);</span>

<span class="nc" id="L71">        long lastLogTimestamp = 0;</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        while (!workflowFinished(restClient, workflowId, executionId)) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (Calendar.getInstance().compareTo(timeoutAt) &gt; 0) {</span>
<span class="nc" id="L74">                throw new WorkflowExecutionException(&quot;Timeout while waiting for workflow to finish.&quot;);</span>
            }
<span class="nc" id="L76">            lastLogTimestamp = printLogMessages(workflowId, executionId, lastLogTimestamp, printedMessages);</span>
            try {
<span class="nc" id="L78">                Thread.sleep(WORKFLOW_FINISH_POLL_INTERVAL);</span>
<span class="nc" id="L79">            } catch (InterruptedException e) {</span>
<span class="nc" id="L80">                throw new WorkflowExecutionException(&quot;Interrupted while waiting for workflow to finish.&quot;, e);</span>
<span class="nc" id="L81">            }</span>
        }

<span class="nc" id="L84">        WorkflowExecution execution = restClient.getExecution(workflowId, executionId);</span>
        try {
<span class="nc" id="L86">            Thread.sleep(WORKFLOW_EXEC_POLL_INTERVAL);</span>
<span class="nc" id="L87">        } catch (InterruptedException e) {</span>
<span class="nc" id="L88">            throw new WorkflowExecutionException(&quot;Interrupted while waiting for workflow logs to be flushed.&quot;, e);</span>
<span class="nc" id="L89">        }</span>
<span class="nc" id="L90">        printLogMessages(workflowId, executionId, lastLogTimestamp, printedMessages);</span>

<span class="nc bnc" id="L92" title="All 4 branches missed.">        if (execution.isFailed() || execution.isCanceled()) {</span>
<span class="nc" id="L93">            throw new WorkflowExecutionException(execution.getError());</span>
        } else {
<span class="nc" id="L95">            return execution;</span>
        }
    }

    private boolean workflowFinished(RestClientVro restClient, String workflowId, String executionId) {
        try {
<span class="nc" id="L101">            return terminalStates.contains(restClient.getExecutionState(workflowId, executionId));</span>
<span class="nc" id="L102">        } catch (RuntimeException rte) {</span>
<span class="nc" id="L103">            handleServiceUnavailableException(&quot;Cannot get status of workflow       &quot;, workflowId, rte);</span>
<span class="nc" id="L104">            return false;</span>
        }
    }

    private long printLogMessages(String workflowId, String executionId, long lastLogTimestamp, Set&lt;String&gt; printedMessages) {
        try {
<span class="nc" id="L110">            final long timestamp = Instant.now().minus(Duration.ofSeconds(30)).toEpochMilli();</span>
<span class="nc" id="L111">            final List&lt;String&gt; logs = restClient.getWorkflowLogs(workflowId, executionId, &quot;debug&quot;, lastLogTimestamp);</span>
<span class="nc" id="L112">            logs.forEach(msg -&gt; {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">                if (!printedMessages.contains(msg)) {</span>
<span class="nc" id="L114">                    final String colorMsg = (msg)</span>
<span class="nc" id="L115">                            .replaceFirst(&quot;\\[(.+?)]&quot;, &quot;[&quot; + BRIGHT_FOREGROUND + &quot;$1&quot; + NORMAL_FOREGROUND + &quot;]&quot;)</span>
<span class="nc" id="L116">                            .replaceFirst(&quot;(?s)\\[warning](.+)&quot;, BRIGHT_YELLOW + &quot;[warning]&quot; + YELLOW + &quot;$1&quot; + NORMAL)</span>
<span class="nc" id="L117">                            .replaceFirst(&quot;(?s)\\[error](.+)&quot;  , BRIGHT_RED    + &quot;[error]&quot;   + RED    + &quot;$1&quot; + NORMAL);</span>
<span class="nc" id="L118">                    System.out.println(colorMsg);</span>
<span class="nc" id="L119">                    printedMessages.add(msg);</span>
                }
<span class="nc" id="L121">            });</span>
<span class="nc" id="L122">            return timestamp;</span>
<span class="nc" id="L123">        } catch (RuntimeException rte) {</span>
<span class="nc" id="L124">            handleServiceUnavailableException(&quot;Cannot get log messages for workflow&quot;, workflowId, rte);</span>
<span class="nc" id="L125">            return lastLogTimestamp;</span>
        }
    }

    private void handleServiceUnavailableException(String failedOperation, String workflowId, RuntimeException rte) {
<span class="nc" id="L130">        System.out.println(RED + failedOperation + &quot; [&quot; + YELLOW + workflowId + RED + &quot;] : &quot;</span>
<span class="nc" id="L131">                + NORMAL + rte.getClass().getName() + &quot; : &quot; + rte.getLocalizedMessage() + &quot;. &quot;</span>
                + GREEN + &quot;Sleeping for &quot; + SERVICE_UNAVAILABLE_SLEEP_MILLIS + &quot; milliseconds.&quot; + NORMAL);
<span class="nc" id="L133">        printStackTrace(rte);</span>
<span class="nc" id="L134">        sleepSilently(SERVICE_UNAVAILABLE_SLEEP_MILLIS); // Give it some more time to recover (1 minute more) and do not fill up the logs so quickly</span>
<span class="nc" id="L135">    }</span>

    private void sleepSilently(long millis) {
        try {
<span class="nc" id="L139">            Thread.sleep(millis);</span>
<span class="nc" id="L140">        } catch (InterruptedException e) {</span>
            // Ignored
<span class="nc" id="L142">        }</span>
<span class="nc" id="L143">    }</span>

    private void printStackTrace(Throwable t) {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (System.getProperty(&quot;DEBUG&quot;) != null) {</span>
<span class="nc" id="L147">            t.printStackTrace();</span>
        }
<span class="nc" id="L149">    }</span>

    public static class WorkflowExecutionException extends Exception {
        private static final long serialVersionUID = -6160545755029886900L;

        public WorkflowExecutionException(String message) {
<span class="nc" id="L155">            super(message);</span>
<span class="nc" id="L156">        }</span>

        public WorkflowExecutionException(String message, Throwable cause) {
<span class="nc" id="L159">            super(message, cause);</span>
<span class="nc" id="L160">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>