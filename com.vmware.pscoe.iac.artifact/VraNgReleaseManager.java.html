<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VraNgReleaseManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">artifact-manager</a> &gt; <a href="index.source.html" class="el_package">com.vmware.pscoe.iac.artifact</a> &gt; <span class="el_source">VraNgReleaseManager.java</span></div><h1>VraNgReleaseManager.java</h1><pre class="source lang-java linenums">package com.vmware.pscoe.iac.artifact;

/*
 * #%L
 * artifact-manager
 * %%
 * Copyright (C) 2023 VMware
 * %%
 * Build Tools for VMware Aria
 * Copyright 2023 VMware, Inc.
 * 
 * This product is licensed to you under the BSD-2 license (the &quot;License&quot;). You may not use this product except in compliance with the BSD-2 License.  
 * 
 * This product may include a number of subcomponents with separate copyright notices and license terms. Your use of these subcomponents is subject to the terms and conditions of the subcomponent's license, as noted in the LICENSE file.
 * #L%
 */

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vmware.pscoe.iac.artifact.model.vrang.VraNgBlueprint;
import com.vmware.pscoe.iac.artifact.rest.RestClientVraNg;


public class VraNgReleaseManager {

    RestClientVraNg restClient;

<span class="fc" id="L39">    private final Logger logger = LoggerFactory.getLogger(VraNgReleaseManager.class);</span>

<span class="fc" id="L41">    public VraNgReleaseManager(RestClientVraNg restClient) {</span>
<span class="fc" id="L42">        this.restClient = restClient;</span>
<span class="fc" id="L43">    }</span>

    public void releaseContent(String contentType, List&lt;String&gt; contentNames, String version, boolean releaseIfNotUpdated) {

<span class="nc bnc" id="L47" title="All 4 branches missed.">        if (contentType.equals(&quot;blueprint&quot;) || contentType.equals(&quot;all&quot;)) {</span>
<span class="nc" id="L48">            List&lt;VraNgBlueprint&gt; blueprints = this.restClient.getAllBlueprints();</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">            if (contentNames.size() &gt; 0) {</span>
<span class="nc" id="L50">                blueprints = blueprints.stream()</span>
<span class="nc" id="L51">                    .filter(bp -&gt; contentNames.contains(bp.getName()))</span>
<span class="nc" id="L52">                    .collect(Collectors.toList());</span>
            }
            
<span class="nc" id="L55">            List&lt;String&gt; invalidBlueprints = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L56">            blueprints.forEach(bp -&gt; {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">                if (this.restClient.isBlueprintVersionPresent(bp.getId(), version)) {</span>
<span class="nc" id="L58">                    invalidBlueprints.add(bp.getName());</span>
                }
<span class="nc" id="L60">            });</span>

<span class="nc bnc" id="L62" title="All 2 branches missed.">            if (invalidBlueprints.size() &gt; 0) {</span>
<span class="nc" id="L63">                throw new RuntimeException(&quot;Blueprints [&quot; + String.join(&quot;, &quot;, invalidBlueprints) + &quot;] already have a released version &quot; + version);</span>
            }

<span class="nc" id="L66">            blueprints.forEach(bp -&gt; {</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">                if (releaseIfNotUpdated == true) {</span>
<span class="nc" id="L68">                    this.restClient.releaseBlueprintVersion(bp.getId(), version);</span>
<span class="nc" id="L69">                    logger.info(&quot;Released blueprint &quot; + bp.getName() + &quot; version &quot; + version);</span>
                } else {
<span class="nc" id="L71">                    this.releaseVersion(bp, version);</span>
                }
<span class="nc" id="L73">            });</span>
        }

<span class="nc" id="L76">    }</span>

    /**
     * Attempt to generate a next version and release it.
     * @param blueprint blueprint
     */
    public void releaseNextVersion(VraNgBlueprint blueprint) {
<span class="fc" id="L83">        String latestVersion = this.restClient.getBlueprintLastUpdatedVersion(blueprint.getId());</span>
<span class="fc" id="L84">        String nextVersion = this.getNextVersion(latestVersion);</span>
<span class="fc" id="L85">        logger.debug(&quot;Next version of blueprint {}: {}&quot;, blueprint.getName(), nextVersion);</span>

        try {
<span class="fc" id="L88">            this.releaseVersion(blueprint, nextVersion);</span>
<span class="fc" id="L89">        } catch (Exception e) {</span>
            // Attempt to fix versions imported in reverse order, which produces an Error on imports
<span class="fc" id="L91">            logger.warn(&quot;Couldn't release version '{}'. Attempting to release date version&quot;, nextVersion);</span>
<span class="fc" id="L92">            this.releaseVersion(blueprint, this.getDateVersion());</span>
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">    }</span>

    /**
     * Release a new version of the blueprint provided that there is no previous version or there are
     * changes in the content since the latest released version.
     * @param blueprint blueprint
     * @param version new version
     */
    public void releaseVersion(VraNgBlueprint blueprint, String version) {
<span class="fc" id="L103">        String latestVersion = this.restClient.getBlueprintLastUpdatedVersion(blueprint.getId());</span>
<span class="pc bpc" id="L104" title="1 of 4 branches missed.">        if (latestVersion == null || this.isUpdated(blueprint, latestVersion)) {</span>
<span class="fc" id="L105">            this.restClient.releaseBlueprintVersion(blueprint.getId(), version);</span>
<span class="fc" id="L106">            logger.info(&quot;Released blueprint &quot; + blueprint.getName() + &quot; version &quot; + version);</span>
        } else {
<span class="nc" id="L108">            logger.info(&quot;Skipping release of blueprint &quot; + blueprint.getName() + &quot;. No changes since latest version.&quot;);</span>
        }
<span class="fc" id="L110">    }</span>

    /**
     * Perform a check whether the blueprint content has been updated since the latest released version.
     * @param blueprint blueprint
     * @param latestVersion latest version
     * @return true if there are changes
     */
    private boolean isUpdated(VraNgBlueprint blueprint, String latestVersion) {
<span class="fc" id="L119">        String draftContent = blueprint.getContent();</span>
<span class="fc" id="L120">        String latestVersionContent = this.restClient.getBlueprintVersionContent(blueprint.getId(), latestVersion);</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (draftContent.equals(latestVersionContent)) {</span>
<span class="nc" id="L122">            return false;</span>
        }

<span class="fc" id="L125">        return true;</span>
    }

    /**
     * Generate next version based on the previous version format.
     * Supported version formats are:
     * * MAJOR
     * * MAJOR.MINOR
     * * MAJOR.MINOR.PATCH
     * A datetime-based version will be returned if the previous version format does not match
     * any of the supported formats.
     * @param version previous version
     * @return next version
     */
    private String getNextVersion(String version) {

<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (version == null) {</span>
            // create a version based on the date and time
<span class="fc" id="L143">            return getDateVersion();</span>
        }

<span class="fc" id="L146">        Matcher major = Pattern.compile(&quot;([0-9]+)&quot;).matcher(version);</span>
<span class="fc" id="L147">        Matcher majorMinor = Pattern.compile(&quot;([0-9]+)\\.([0-9]+)&quot;).matcher(version);</span>
<span class="fc" id="L148">        Matcher majorMinorPatch = Pattern.compile(&quot;([0-9]+)\\.([0-9]+)\\.([0-9]+)&quot;).matcher(version);</span>

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (majorMinorPatch.matches()) {</span>
<span class="nc" id="L151">            logger.debug(&quot;Detected version pattern MAJOR.MINOR.PATCH from {} with incrementable segment '{}'&quot;, version, majorMinorPatch.group(3));</span>
            // increment the patch segment
<span class="nc" id="L153">            return majorMinorPatch.group(1) + &quot;.&quot; + majorMinorPatch.group(2) + &quot;.&quot; + (Integer.parseInt(majorMinorPatch.group(3)) + 1);</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        } else if (majorMinor.matches()) {</span>
<span class="nc" id="L155">            logger.debug(&quot;Detected version pattern MAJOR.MINOR from '{}' with incrementable segment '{}'&quot;, version, majorMinor.group(2));</span>
            // increment the minor segment
<span class="nc" id="L157">            return majorMinor.group(1) + &quot;.&quot; + (Integer.parseInt(majorMinor.group(2)) + 1);</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        } else if (major.matches()) {</span>
<span class="fc" id="L159">            logger.debug(&quot;Detected version pattern MAJOR from '{}' with incrementable segment '{}'&quot;, version, major.group(1));</span>
            // increment the major segment
<span class="fc" id="L161">            return Integer.toString(Integer.parseInt(major.group(1)) + 1);</span>
        } else {
<span class="nc" id="L163">            logger.debug(&quot;Could not determine version pattern from {}&quot;, version);</span>
<span class="nc" id="L164">            return getDateVersion();</span>
        }

    }

    /**
     * Create a version based on the current date and time.
     * @return datetime-based version
     */
    private String getDateVersion() {
<span class="fc" id="L174">        Date date = Calendar.getInstance().getTime();</span>
<span class="fc" id="L175">        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span>
<span class="fc" id="L176">        return dateFormat.format(date);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>